{"version":3,"sources":["components/disc/Disc.js","utilities/ClassNames.js","components/board/Board.js","components/game/Game.js","App.js","serviceWorker.js","index.js"],"names":["Disc","isMatchClass","this","props","isMatch","className","value","disabled","onClick","Component","classNames","classObject","classes","key","hasOwnProperty","push","join","Board","getColumnIndex","index","WIDTH","config","handleOnMouseOver","rowIndex","setState","hoveredRow","handleOnMouseOut","getSlotClassName","columnIndex","state","discs","map","disc","matches","includes","onMouseOver","onMouseOut","data-column","onDiscClick","BOARD_CONFIG","HEIGHT","Game","getNextSlot","slotsInClickedRow","forEach","length","handleOnDiscClick","xIsNext","checkForWinner","fourInARow","horizontalFourInARow","checkForHorizontalMatches","Math","ceil","diagonalRightFourInARow","diagonalLeftFourInARow","verticalFourInARow","checkForVerticalMatches","checkForDiagonalRightMatches","checkForDiagonalLeftMatches","isFourInARow","i","localIndex","nextDisc","matchLength","Array","fill","isWinner","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e95c9c90.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './Disc.scss';\n\nclass Disc extends Component {\n    render() {\n        const isMatchClass = this.props.isMatch ? 'disc_isMatch' : '';\n        return (\n            <button className={`disc disc_${this.props.value} ${isMatchClass}`} disabled={this.props.value} onClick={this.props.onClick}>\n                <span className=\"disc-value\">{this.props.value}</span>\n                <div className=\"disc-piece\"></div>\n            </button>\n        );\n    }\n}\n\nexport default Disc;\n","const classNames = classObject => {\n    const classes = [];\n\n    if (typeof classObject === 'object') {\n        for (const key in classObject) {\n            if (classObject.hasOwnProperty(key) && classObject[key]) {\n                classes.push(key);\n            }\n        }\n    }\n\n    return classes.join(' ');\n};\n\nexport default classNames;\n","import React, { Component } from 'react';\nimport Disc from '../disc/Disc';\nimport './Board.scss';\nimport classNames from '../../utilities/ClassNames';\n\nclass Board extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            hoveredRow: null,\n        };\n    }\n    getColumnIndex = (index) => {\n        const { WIDTH } = this.props.config;\n\n        return index < WIDTH ? index : index % WIDTH;\n    };\n\n    handleOnMouseOver = (rowIndex) => {\n        this.setState({ hoveredRow: rowIndex });\n    };\n\n    handleOnMouseOut = (rowIndex) => {\n        this.setState({ hoveredRow: null });\n    };\n\n    getSlotClassName = (columnIndex) => {\n        return classNames({\n            'board-slot': true,\n            'board-slot_isActive': columnIndex === this.state.hoveredRow,\n        });\n    };\n\n    render() {\n        return (\n            <ul className={`board board_${this.props.config.WIDTH}up`}>\n                {this.props.discs.map((disc, index) => {\n                    const isMatch = this.props.matches.includes(index);\n                    const columnIndex = this.getColumnIndex(index);\n                    return (\n                        <li\n                            key={`slot_${index}`}\n                            onMouseOver={() => this.handleOnMouseOver(columnIndex)}\n                            onMouseOut={() => this.handleOnMouseOut()}\n                            className={this.getSlotClassName(columnIndex)}\n                            data-column={columnIndex}\n                        >\n                            <Disc value={disc} isMatch={isMatch} onClick={() => this.props.onDiscClick(columnIndex)} />\n                        </li>\n                    );\n                })}\n            </ul>\n        );\n    }\n}\n\nexport default Board;\n","import React, { Component } from 'react';\nimport Board from '../board/Board';\n\nconst BOARD_CONFIG = {\n    HEIGHT: 6,\n    WIDTH: 7,\n};\n\nclass Game extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            discs: Array(BOARD_CONFIG.HEIGHT * BOARD_CONFIG.WIDTH).fill(null),\n            isWinner: false,\n        };\n    }\n\n    getNextSlot = (rowIndex) => {\n        let slotsInClickedRow = [];\n        const { WIDTH } = BOARD_CONFIG;\n        this.state.discs.forEach((disc, index) => {\n            if (disc) {\n                return;\n            }\n\n            if (rowIndex === index || index % WIDTH === rowIndex) {\n                slotsInClickedRow.push(index);\n            }\n        });\n\n        return slotsInClickedRow[slotsInClickedRow.length - 1];\n    };\n\n    handleOnDiscClick = (rowIndex) => {\n        const discs = [...this.state.discs];\n        const nextSlotIndex = this.getNextSlot(rowIndex);\n\n        discs[nextSlotIndex] = this.state.xIsNext ? 'X' : 'O';\n        this.setState({\n            discs: discs,\n            xIsNext: !this.state.xIsNext,\n        });\n    };\n\n    checkForWinner = () => {\n        let fourInARow = false;\n        let matches = [];\n\n        this.state.discs.forEach((disc, index) => {\n            if (!disc || fourInARow) {\n                return;\n            }\n\n            // horizontal check\n            let horizontalFourInARow = {};\n            if (index % BOARD_CONFIG.WIDTH <= 4) {\n                horizontalFourInARow = this.checkForHorizontalMatches(disc, index);\n            }\n\n            // vertical check\n            const minRemainingRowsToMatchVertical = Math.ceil(BOARD_CONFIG.HEIGHT - (index + 1) / BOARD_CONFIG.WIDTH);\n\n            if (minRemainingRowsToMatchVertical >= 4) {\n                let diagonalRightFourInARow = {};\n                let diagonalLeftFourInARow = {};\n\n                const verticalFourInARow = this.checkForVerticalMatches(disc, index);\n                if (BOARD_CONFIG.WIDTH - index >= 4) {\n                    diagonalRightFourInARow = this.checkForDiagonalRightMatches(disc, index);\n                }\n                if (BOARD_CONFIG.WIDTH - index <= 4) {\n                    diagonalLeftFourInARow = this.checkForDiagonalLeftMatches(disc, index);\n                }\n\n                if (horizontalFourInARow.isFourInARow) {\n                    matches = horizontalFourInARow.matches;\n                    fourInARow = horizontalFourInARow.isFourInARow;\n                }\n                if (verticalFourInARow.isFourInARow) {\n                    matches = verticalFourInARow.matches;\n                    fourInARow = verticalFourInARow.isFourInARow;\n                }\n                if (diagonalLeftFourInARow.isFourInARow) {\n                    matches = diagonalLeftFourInARow.matches;\n                    fourInARow = diagonalLeftFourInARow.isFourInARow;\n                }\n                if (diagonalRightFourInARow.isFourInARow) {\n                    matches = diagonalRightFourInARow.matches;\n                    fourInARow = diagonalRightFourInARow.isFourInARow;\n                }\n            }\n            return fourInARow;\n        });\n        return { fourInARow, matches };\n    };\n\n    checkForHorizontalMatches = (disc, index) => {\n        let horizontalFourInARow = false;\n        const matchLength = 3;\n        let i = 0;\n        let localIndex = index;\n        let matches = [index];\n\n        for (; i < matchLength; i++) {\n            const nextDisc = this.state.discs[localIndex + 1];\n            if (!nextDisc) {\n                horizontalFourInARow = false;\n                break;\n            }\n\n            if (disc === nextDisc) {\n                localIndex = localIndex + 1;\n                matches.push(localIndex);\n            }\n            if (disc === nextDisc && i === matchLength - 1) {\n                horizontalFourInARow = true;\n                break;\n            }\n        }\n\n        return { isFourInARow: horizontalFourInARow, matches };\n    };\n\n    checkForVerticalMatches = (disc, index) => {\n        let verticalFourInARow = false;\n        const matchLength = 3;\n        let i = 0;\n        let localIndex = index;\n        let matches = [index];\n        for (; i < matchLength; i++) {\n            const nextDisc = this.state.discs[localIndex + BOARD_CONFIG.WIDTH];\n\n            if (!nextDisc) {\n                verticalFourInARow = false;\n                break;\n            }\n            if (disc === nextDisc) {\n                localIndex = localIndex + BOARD_CONFIG.WIDTH;\n                matches.push(localIndex);\n            }\n\n            if (disc === nextDisc && i === matchLength - 1) {\n                verticalFourInARow = true;\n\n                break;\n            }\n        }\n        return { isFourInARow: verticalFourInARow, matches };\n    };\n\n    checkForDiagonalLeftMatches = (disc, index) => {\n        let diagonalLeftFourInARow = false;\n        const matchLength = 3;\n        let i = 0;\n        let localIndex = index;\n        let matches = [index];\n        for (; i < matchLength; i++) {\n            const nextDisc = this.state.discs[localIndex + BOARD_CONFIG.WIDTH - 1];\n\n            if (!nextDisc) {\n                diagonalLeftFourInARow = false;\n                break;\n            }\n            if (disc === nextDisc) {\n                localIndex = localIndex + BOARD_CONFIG.WIDTH - 1;\n                matches.push(localIndex);\n            }\n\n            if (disc === nextDisc && i === matchLength - 1) {\n                diagonalLeftFourInARow = true;\n                break;\n            }\n        }\n\n        return { isFourInARow: diagonalLeftFourInARow, matches };\n    };\n\n    checkForDiagonalRightMatches = (disc, index) => {\n        let diagonalRightFourInARow = false;\n        const matchLength = 3;\n        let i = 0;\n        let localIndex = index;\n        let matches = [index];\n        for (; i < matchLength; i++) {\n            const nextDisc = this.state.discs[localIndex + BOARD_CONFIG.WIDTH + 1];\n\n            if (!nextDisc) {\n                diagonalRightFourInARow = false;\n                break;\n            }\n            if (disc === nextDisc) {\n                localIndex = localIndex + BOARD_CONFIG.WIDTH + 1;\n                matches.push(localIndex);\n            }\n\n            if (disc === nextDisc && i === matchLength - 1) {\n                diagonalRightFourInARow = true;\n                break;\n            }\n        }\n        return { isFourInARow: diagonalRightFourInARow, matches };\n    };\n\n    render() {\n        const { fourInARow, matches } = this.checkForWinner();\n\n        return (\n            <>\n                {fourInARow && <div>We have a winner</div>}\n                <Board discs={this.state.discs} config={BOARD_CONFIG} onDiscClick={this.handleOnDiscClick} matches={matches} />\n            </>\n        );\n    }\n}\n\nexport default Game;\n","import React from 'react';\n\nimport './App.scss';\nimport Game from './components/game/Game';\n\nfunction App() {\n    return (\n        <div className=\"App\">\n            <div className=\"seatBelt\">\n                <Game />\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}